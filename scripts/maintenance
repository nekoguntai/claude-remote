#!/usr/bin/env bash
#
# maintenance - Cleanup and maintenance tasks for Claude Remote
#
# Run periodically (e.g., weekly via cron) to keep the server healthy
# for perpetual operation.
#
# Usage:
#   maintenance          # Run all maintenance tasks
#   maintenance --dry-run    # Show what would be done without doing it
#   maintenance --logs       # Only rotate logs
#   maintenance --mosh       # Only cleanup orphaned mosh servers
#   maintenance --sessions   # Only show idle session info
#

set -e

# Ensure Homebrew is in PATH on macOS (for cron/launchd execution)
if [[ "$OSTYPE" == "darwin"* ]]; then
    if [[ -f "/opt/homebrew/bin/brew" ]]; then
        eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [[ -f "/usr/local/bin/brew" ]]; then
        eval "$(/usr/local/bin/brew shellenv)"
    fi
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

LOCAL_SHARE="${HOME}/.local/share/claude-remote"
DRY_RUN=false
RUN_LOGS=true
RUN_MOSH=true
RUN_SESSIONS=true

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --logs)
            RUN_MOSH=false
            RUN_SESSIONS=false
            shift
            ;;
        --mosh)
            RUN_LOGS=false
            RUN_SESSIONS=false
            shift
            ;;
        --sessions)
            RUN_LOGS=false
            RUN_MOSH=false
            shift
            ;;
        --help|-h)
            echo "Usage: maintenance [--dry-run] [--logs|--mosh|--sessions]"
            echo ""
            echo "Options:"
            echo "  --dry-run    Show what would be done without doing it"
            echo "  --logs       Only rotate logs"
            echo "  --mosh       Only cleanup orphaned mosh servers"
            echo "  --sessions   Only show idle session info"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            exit 1
            ;;
    esac
done

print_header() {
    echo -e "\n${BOLD}${CYAN}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}                Claude Remote Maintenance                    ${NC}"
    echo -e "${BOLD}${CYAN}═══════════════════════════════════════════════════════════${NC}"
    if $DRY_RUN; then
        echo -e "${YELLOW}                      (DRY RUN MODE)${NC}"
    fi
    echo ""
}

print_section() {
    echo -e "\n${BOLD}${BLUE}▶ $1${NC}"
    echo -e "${BLUE}─────────────────────────────────────────────────────────────${NC}"
}

# ============================================================================
# Log Rotation (for macOS file-based logs)
# ============================================================================
rotate_logs() {
    print_section "Log Rotation"

    if [[ ! -d "$LOCAL_SHARE" ]]; then
        echo -e "  ${YELLOW}No log directory found${NC}"
        return
    fi

    local log_files=("$LOCAL_SHARE/ttyd.log" "$LOCAL_SHARE/ttyd.error.log")
    local max_size=$((10 * 1024 * 1024))  # 10MB
    local keep_rotated=4

    for log_file in "${log_files[@]}"; do
        if [[ ! -f "$log_file" ]]; then
            continue
        fi

        local size=$(stat -f%z "$log_file" 2>/dev/null || stat -c%s "$log_file" 2>/dev/null || echo "0")
        local size_mb=$((size / 1024 / 1024))
        local basename=$(basename "$log_file")

        echo -e "  ${basename}: ${size_mb}MB"

        if [[ $size -gt $max_size ]]; then
            echo -e "    ${YELLOW}Exceeds 10MB limit, rotating...${NC}"

            if $DRY_RUN; then
                echo -e "    ${BLUE}[DRY RUN] Would rotate ${basename}${NC}"
            else
                # Rotate existing backups
                for i in $(seq $((keep_rotated - 1)) -1 1); do
                    if [[ -f "${log_file}.$i" ]]; then
                        mv "${log_file}.$i" "${log_file}.$((i + 1))"
                    fi
                done

                # Rotate current log
                mv "$log_file" "${log_file}.1"
                touch "$log_file"
                chmod 600 "$log_file"

                # Remove oldest if exceeds keep count
                if [[ -f "${log_file}.$((keep_rotated + 1))" ]]; then
                    rm -f "${log_file}.$((keep_rotated + 1))"
                fi

                echo -e "    ${GREEN}Rotated${NC}"
            fi
        else
            echo -e "    ${GREEN}OK (under 10MB limit)${NC}"
        fi
    done

    # Show total log disk usage
    local total_size=$(du -sh "$LOCAL_SHARE" 2>/dev/null | cut -f1)
    echo -e "\n  Total log directory size: ${total_size}"
}

# ============================================================================
# Orphaned Mosh Server Cleanup
# ============================================================================
cleanup_mosh() {
    print_section "Mosh Server Cleanup"

    if ! command -v mosh-server &> /dev/null; then
        echo -e "  ${YELLOW}mosh-server not installed${NC}"
        return
    fi

    # Find mosh-server processes
    local mosh_pids=$(pgrep -x mosh-server 2>/dev/null || true)

    if [[ -z "$mosh_pids" ]]; then
        echo -e "  ${GREEN}No mosh-server processes running${NC}"
        return
    fi

    local count=$(echo "$mosh_pids" | wc -l | tr -d ' ')
    echo -e "  Found ${count} mosh-server process(es)"

    # Check for orphaned processes (no associated terminal)
    local orphaned=0
    local active=0

    for pid in $mosh_pids; do
        # Get process info
        local elapsed=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ')
        local tty=$(ps -o tty= -p "$pid" 2>/dev/null | tr -d ' ')

        # Check if the process has been running for more than 24 hours
        # and has no controlling terminal (potential orphan)
        if [[ "$tty" == "?" || "$tty" == "??" ]]; then
            # Parse elapsed time to check if > 24 hours
            # Format can be: MM:SS, HH:MM:SS, or D-HH:MM:SS
            local days=0
            if [[ "$elapsed" =~ ^([0-9]+)-.*$ ]]; then
                days="${BASH_REMATCH[1]}"
            fi

            if [[ $days -ge 1 ]]; then
                orphaned=$((orphaned + 1))
                echo -e "  ${YELLOW}PID $pid: running for $elapsed (potential orphan)${NC}"

                if $DRY_RUN; then
                    echo -e "    ${BLUE}[DRY RUN] Would send SIGTERM to PID $pid${NC}"
                else
                    # Send SIGTERM to allow graceful shutdown
                    kill -TERM "$pid" 2>/dev/null || true
                    echo -e "    ${GREEN}Sent SIGTERM${NC}"
                fi
            else
                active=$((active + 1))
            fi
        else
            active=$((active + 1))
        fi
    done

    echo -e "\n  Summary: ${active} active, ${orphaned} orphaned (cleaned)"
}

# ============================================================================
# Session Information
# ============================================================================
show_sessions() {
    print_section "tmux Sessions"

    if ! command -v tmux &> /dev/null; then
        echo -e "  ${YELLOW}tmux not installed${NC}"
        return
    fi

    if ! tmux list-sessions 2>/dev/null; then
        echo -e "  ${YELLOW}No active tmux sessions${NC}"
        return
    fi

    echo ""

    # Show session details with last activity
    while IFS= read -r session; do
        local name=$(echo "$session" | cut -d: -f1)
        local windows=$(tmux list-windows -t "$name" 2>/dev/null | wc -l | tr -d ' ')
        local attached=$(tmux list-clients -t "$name" 2>/dev/null | wc -l | tr -d ' ')

        local status=""
        if [[ $attached -gt 0 ]]; then
            status="${GREEN}attached${NC}"
        else
            status="${YELLOW}detached${NC}"
        fi

        echo -e "  ${BOLD}$name${NC}: $windows window(s), $status"
    done < <(tmux list-sessions -F "#{session_name}" 2>/dev/null)

    echo -e "\n  ${BLUE}Tip: Use 'claude-session --kill <name>' to remove unused sessions${NC}"
}

# ============================================================================
# Disk Space Check
# ============================================================================
check_disk_space() {
    print_section "Disk Space"

    local home_usage=$(df -h "$HOME" | tail -1 | awk '{print $5}')
    local home_avail=$(df -h "$HOME" | tail -1 | awk '{print $4}')

    echo -e "  Home directory: ${home_usage} used, ${home_avail} available"

    # Warn if over 90%
    local percent=$(echo "$home_usage" | tr -d '%')
    if [[ $percent -gt 90 ]]; then
        echo -e "  ${RED}WARNING: Disk space critically low!${NC}"
    elif [[ $percent -gt 80 ]]; then
        echo -e "  ${YELLOW}WARNING: Disk space getting low${NC}"
    else
        echo -e "  ${GREEN}Disk space OK${NC}"
    fi
}

# ============================================================================
# Main
# ============================================================================
main() {
    print_header

    $RUN_LOGS && rotate_logs
    $RUN_MOSH && cleanup_mosh
    $RUN_SESSIONS && show_sessions

    # Always show disk space
    check_disk_space

    echo -e "\n${BOLD}${GREEN}Maintenance complete!${NC}\n"
}

main
